from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.db.session import SessionLocal
from app.db.models.interview_session import InterviewSession
from app.db.models.interview_evaluation import InterviewEvaluation
from app.db.models.candidate_benchmark import CandidateBenchmark
from app.db.models.user import User
from app.services.ai_engine import generate_auto_coach_plan
from app.services.ai_engine import generate_weekly_progress_report



from app.core.auth_dependency import get_current_user
from app.services.ai_engine import (
    generate_live_answer,
    star_formatter,
    evaluate_interview_performance
)

router = APIRouter(prefix="/interview", tags=["Interview"])


# ✅ DB DEPENDENCY
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ✅ START INTERVIEW SESSION
@router.post("/start")
def start_session(
    job_title: str,
    company: str = "",
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    session = InterviewSession(
        user_id=user.id,
        job_title=job_title,
        company=company
    )
    db.add(session)
    db.commit()
    db.refresh(session)

    return {
        "session_id": session.id,
        "status": "started"
    }


# ✅ END INTERVIEW SESSION
@router.post("/end")
def end_session(
    session_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    session = db.query(InterviewSession).filter(
        InterviewSession.id == session_id,
        InterviewSession.user_id == user.id
    ).first()

    if not session:
        return {"error": "Session not found"}

    session.status = "ended"
    db.commit()

    return {"message": "Interview session ended"}


# ✅ LIVE AI ANSWER (REAL-TIME COPILOT)
@router.post("/live-answer")
def live_answer(
    session_id: int,
    question: str,
    resume_text: str,
    jd_text: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    session = db.query(InterviewSession).filter(
        InterviewSession.id == session_id,
        InterviewSession.user_id == user.id
    ).first()

    if not session:
        return {"error": "Invalid session"}

    answer = generate_live_answer(question, resume_text, jd_text)

    return {"answer": answer}


# ✅ STAR FORMAT ANSWER
@router.post("/star-answer")
def star_answer(
    session_id: int,
    question: str,
    resume_text: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    session = db.query(InterviewSession).filter(
        InterviewSession.id == session_id,
        InterviewSession.user_id == user.id
    ).first()

    if not session:
        return {"error": "Invalid session"}

    star = star_formatter(question, resume_text)

    return {"star_answer": star}


# ✅ POST-INTERVIEW AI EVALUATION + AUTO BENCHMARK
@router.post("/evaluate")
def evaluate_interview(
    session_id: int,
    transcript: str,
    jd_text: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    session = db.query(InterviewSession).filter(
        InterviewSession.id == session_id,
        InterviewSession.user_id == user.id
    ).first()

    if not session:
        return {"error": "Invalid session"}

    result = evaluate_interview_performance(transcript, jd_text)

    # ✅ TEMP STATIC SCORES (AI parsing can automate later)
    communication = 8.0
    technical = 7.5
    confidence = 8.2
    role_fit = 85.0

    evaluation = InterviewEvaluation(
        session_id=session_id,
        communication_score=communication,
        technical_score=technical,
        confidence_score=confidence,
        role_fit_score=role_fit,
        strengths="Auto-generated by AI",
        weaknesses="Auto-generated by AI",
        improvement_plan=result
    )

    benchmark = CandidateBenchmark(
        job_title=session.job_title,
        candidate_id=user.id,
        session_id=session_id,
        communication_score=communication,
        technical_score=technical,
        confidence_score=confidence,
        role_fit_score=role_fit
    )

    db.add(evaluation)
    db.add(benchmark)
    db.commit()
    db.refresh(evaluation)

    return {
        "evaluation_id": evaluation.id,
        "analysis": result
    }


# ✅ RECRUITER COMPARISON LEADERBOARD
@router.get("/recruiter/compare")
def recruiter_leaderboard(
    job_title: str,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    ranked = db.query(CandidateBenchmark) \
        .filter(CandidateBenchmark.job_title == job_title) \
        .order_by(CandidateBenchmark.role_fit_score.desc()) \
        .all()

    return [
        {
            "candidate_id": r.candidate_id,
            "communication": r.communication_score,
            "technical": r.technical_score,
            "confidence": r.confidence_score,
            "role_fit": r.role_fit_score
        }
        for r in ranked
    ]

# ✅ PERFORMANCE TREND TRACKING (USER GROWTH OVER TIME)
@router.get("/trends")
def interview_trends(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    records = db.query(InterviewEvaluation) \
        .join(InterviewSession) \
        .filter(InterviewSession.user_id == user.id) \
        .order_by(InterviewEvaluation.id.asc()) \
        .all()

    return {
        "total_sessions": len(records),
        "communication_trend": [r.communication_score for r in records],
        "technical_trend": [r.technical_score for r in records],
        "confidence_trend": [r.confidence_score for r in records],
        "role_fit_trend": [r.role_fit_score for r in records]
    }

# ✅ AI AUTO-COACH ENGINE
@router.post("/auto-coach")
def auto_coach(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    latest = db.query(InterviewEvaluation) \
        .join(InterviewSession) \
        .filter(InterviewSession.user_id == user.id) \
        .order_by(InterviewEvaluation.id.desc()) \
        .first()

    if not latest:
        return {"error": "No interview data yet"}

    plan = generate_auto_coach_plan(
        latest.communication_score,
        latest.technical_score,
        latest.confidence_score,
        latest.role_fit_score
    )

    return {
        "weak_area": min(
            [
                ("communication", latest.communication_score),
                ("technical", latest.technical_score),
                ("confidence", latest.confidence_score),
                ("role_fit", latest.role_fit_score)
            ],
            key=lambda x: x[1]
        )[0],
        "ai_coach_plan": plan
    }


# ✅ WEEKLY AI CAREER PROGRESS REPORT
@router.get("/weekly-report")
def weekly_report(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    records = db.query(InterviewEvaluation) \
        .join(InterviewSession) \
        .filter(InterviewSession.user_id == user.id) \
        .order_by(InterviewEvaluation.id.desc()) \
        .limit(2) \
        .all()

    if len(records) < 2:
        return {"error": "Need at least 2 interviews to generate report"}

    latest = records[0]
    previous = records[1]

    latest_scores = {
        "communication": latest.communication_score,
        "technical": latest.technical_score,
        "confidence": latest.confidence_score,
        "role_fit": latest.role_fit_score,
    }

    previous_scores = {
        "communication": previous.communication_score,
        "technical": previous.technical_score,
        "confidence": previous.confidence_score,
        "role_fit": previous.role_fit_score,
    }

    report = generate_weekly_progress_report(previous_scores, latest_scores)

    return {
        "latest_scores": latest_scores,
        "previous_scores": previous_scores,
        "weekly_report": report
    }
# ✅ WEEKLY AI CAREER PROGRESS REPORT
@router.get("/weekly-report")
def weekly_report(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user)
):
    records = (
        db.query(InterviewEvaluation)
        .join(InterviewSession)
        .filter(InterviewSession.user_id == user.id)
        .order_by(InterviewEvaluation.id.desc())
        .limit(2)
        .all()
    )

    if len(records) < 2:
        return {"error": "Need at least 2 interviews to generate weekly report"}

    latest = records[0]
    previous = records[1]

    latest_scores = {
        "communication": float(latest.communication_score),
        "technical": float(latest.technical_score),
        "confidence": float(latest.confidence_score),
        "role_fit": float(latest.role_fit_score),
    }

    previous_scores = {
        "communication": float(previous.communication_score),
        "technical": float(previous.technical_score),
        "confidence": float(previous.confidence_score),
        "role_fit": float(previous.role_fit_score),
    }

    report = generate_weekly_progress_report(previous_scores, latest_scores)

    return {
        "latest_scores": latest_scores,
        "previous_scores": previous_scores,
        "weekly_report": report,
    }
